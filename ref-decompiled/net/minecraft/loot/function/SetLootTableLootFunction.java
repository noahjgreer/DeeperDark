package net.minecraft.loot.function;

import com.mojang.serialization.Codec;
import com.mojang.serialization.MapCodec;
import com.mojang.serialization.codecs.RecordCodecBuilder;
import java.util.List;
import net.minecraft.block.entity.BlockEntityType;
import net.minecraft.component.DataComponentTypes;
import net.minecraft.component.type.ContainerLootComponent;
import net.minecraft.item.ItemStack;
import net.minecraft.loot.LootTable;
import net.minecraft.loot.LootTableReporter;
import net.minecraft.loot.context.LootContext;
import net.minecraft.registry.Registries;
import net.minecraft.registry.RegistryKey;
import net.minecraft.registry.entry.RegistryEntry;

public class SetLootTableLootFunction extends ConditionalLootFunction {
   public static final MapCodec CODEC = RecordCodecBuilder.mapCodec((instance) -> {
      return addConditionsField(instance).and(instance.group(LootTable.TABLE_KEY.fieldOf("name").forGetter((function) -> {
         return function.lootTable;
      }), Codec.LONG.optionalFieldOf("seed", 0L).forGetter((function) -> {
         return function.seed;
      }), Registries.BLOCK_ENTITY_TYPE.getEntryCodec().fieldOf("type").forGetter((function) -> {
         return function.type;
      }))).apply(instance, SetLootTableLootFunction::new);
   });
   private final RegistryKey lootTable;
   private final long seed;
   private final RegistryEntry type;

   private SetLootTableLootFunction(List conditions, RegistryKey lootTable, long seed, RegistryEntry blockEntityType) {
      super(conditions);
      this.lootTable = lootTable;
      this.seed = seed;
      this.type = blockEntityType;
   }

   public LootFunctionType getType() {
      return LootFunctionTypes.SET_LOOT_TABLE;
   }

   public ItemStack process(ItemStack stack, LootContext context) {
      if (stack.isEmpty()) {
         return stack;
      } else {
         stack.set(DataComponentTypes.CONTAINER_LOOT, new ContainerLootComponent(this.lootTable, this.seed));
         return stack;
      }
   }

   public void validate(LootTableReporter reporter) {
      super.validate(reporter);
      if (!reporter.canUseReferences()) {
         reporter.report(new LootTableReporter.ReferenceNotAllowedError(this.lootTable));
      } else {
         if (reporter.getDataLookup().getOptionalEntry(this.lootTable).isEmpty()) {
            reporter.report(new LootTableReporter.MissingElementError(this.lootTable));
         }

      }
   }

   public static ConditionalLootFunction.Builder builder(BlockEntityType type, RegistryKey lootTable) {
      return builder((conditions) -> {
         return new SetLootTableLootFunction(conditions, lootTable, 0L, type.getRegistryEntry());
      });
   }

   public static ConditionalLootFunction.Builder builder(BlockEntityType type, RegistryKey lootTable, long seed) {
      return builder((conditions) -> {
         return new SetLootTableLootFunction(conditions, lootTable, seed, type.getRegistryEntry());
      });
   }
}
