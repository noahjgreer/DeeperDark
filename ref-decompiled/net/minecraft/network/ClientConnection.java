package net.minecraft.network;

import com.google.common.base.Suppliers;
import com.google.common.collect.Queues;
import com.google.common.util.concurrent.ThreadFactoryBuilder;
import com.mojang.logging.LogUtils;
import io.netty.bootstrap.Bootstrap;
import io.netty.channel.Channel;
import io.netty.channel.ChannelException;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelFutureListener;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandler;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelOutboundHandler;
import io.netty.channel.ChannelOutboundHandlerAdapter;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.ChannelPromise;
import io.netty.channel.DefaultEventLoopGroup;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.SimpleChannelInboundHandler;
import io.netty.channel.epoll.Epoll;
import io.netty.channel.epoll.EpollEventLoopGroup;
import io.netty.channel.epoll.EpollSocketChannel;
import io.netty.channel.local.LocalChannel;
import io.netty.channel.local.LocalServerChannel;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.nio.NioSocketChannel;
import io.netty.handler.flow.FlowControlHandler;
import io.netty.handler.timeout.ReadTimeoutHandler;
import io.netty.handler.timeout.TimeoutException;
import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.nio.channels.ClosedChannelException;
import java.util.Objects;
import java.util.Queue;
import java.util.concurrent.RejectedExecutionException;
import java.util.function.Consumer;
import java.util.function.Supplier;
import javax.crypto.Cipher;
import net.minecraft.SharedConstants;
import net.minecraft.network.encryption.PacketDecryptor;
import net.minecraft.network.encryption.PacketEncryptor;
import net.minecraft.network.handler.DecoderHandler;
import net.minecraft.network.handler.EncoderHandler;
import net.minecraft.network.handler.LocalBufPacker;
import net.minecraft.network.handler.LocalBufUnpacker;
import net.minecraft.network.handler.NetworkStateTransitions;
import net.minecraft.network.handler.PacketBundleHandler;
import net.minecraft.network.handler.PacketBundler;
import net.minecraft.network.handler.PacketDeflater;
import net.minecraft.network.handler.PacketException;
import net.minecraft.network.handler.PacketInflater;
import net.minecraft.network.handler.PacketSizeLogHandler;
import net.minecraft.network.handler.PacketSizeLogger;
import net.minecraft.network.handler.PacketUnbundler;
import net.minecraft.network.handler.SizePrepender;
import net.minecraft.network.handler.SplitterHandler;
import net.minecraft.network.listener.ClientLoginPacketListener;
import net.minecraft.network.listener.ClientPacketListener;
import net.minecraft.network.listener.ClientQueryPacketListener;
import net.minecraft.network.listener.PacketListener;
import net.minecraft.network.listener.TickablePacketListener;
import net.minecraft.network.packet.Packet;
import net.minecraft.network.packet.c2s.handshake.ConnectionIntent;
import net.minecraft.network.packet.c2s.handshake.HandshakeC2SPacket;
import net.minecraft.network.packet.s2c.common.DisconnectS2CPacket;
import net.minecraft.network.packet.s2c.login.LoginDisconnectS2CPacket;
import net.minecraft.network.state.HandshakeStates;
import net.minecraft.network.state.LoginStates;
import net.minecraft.network.state.NetworkState;
import net.minecraft.network.state.QueryStates;
import net.minecraft.text.Text;
import net.minecraft.util.Util;
import net.minecraft.util.math.MathHelper;
import net.minecraft.util.profiler.MultiValueDebugSampleLogImpl;
import org.apache.commons.lang3.Validate;
import org.jetbrains.annotations.Nullable;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

public class ClientConnection extends SimpleChannelInboundHandler {
   private static final float CURRENT_PACKET_COUNTER_WEIGHT = 0.75F;
   private static final Logger LOGGER = LogUtils.getLogger();
   public static final Marker NETWORK_MARKER = MarkerFactory.getMarker("NETWORK");
   public static final Marker NETWORK_PACKETS_MARKER = (Marker)Util.make(MarkerFactory.getMarker("NETWORK_PACKETS"), (marker) -> {
      marker.add(NETWORK_MARKER);
   });
   public static final Marker PACKET_RECEIVED_MARKER = (Marker)Util.make(MarkerFactory.getMarker("PACKET_RECEIVED"), (marker) -> {
      marker.add(NETWORK_PACKETS_MARKER);
   });
   public static final Marker PACKET_SENT_MARKER = (Marker)Util.make(MarkerFactory.getMarker("PACKET_SENT"), (marker) -> {
      marker.add(NETWORK_PACKETS_MARKER);
   });
   public static final Supplier CLIENT_IO_GROUP = Suppliers.memoize(() -> {
      return new NioEventLoopGroup(0, (new ThreadFactoryBuilder()).setNameFormat("Netty Client IO #%d").setDaemon(true).build());
   });
   public static final Supplier EPOLL_CLIENT_IO_GROUP = Suppliers.memoize(() -> {
      return new EpollEventLoopGroup(0, (new ThreadFactoryBuilder()).setNameFormat("Netty Epoll Client IO #%d").setDaemon(true).build());
   });
   public static final Supplier LOCAL_CLIENT_IO_GROUP = Suppliers.memoize(() -> {
      return new DefaultEventLoopGroup(0, (new ThreadFactoryBuilder()).setNameFormat("Netty Local Client IO #%d").setDaemon(true).build());
   });
   private static final NetworkState C2S_HANDSHAKE_STATE;
   private final NetworkSide side;
   private volatile boolean duringLogin = true;
   private final Queue queuedTasks = Queues.newConcurrentLinkedQueue();
   private Channel channel;
   private SocketAddress address;
   @Nullable
   private volatile PacketListener prePlayStateListener;
   @Nullable
   private volatile PacketListener packetListener;
   @Nullable
   private DisconnectionInfo disconnectionInfo;
   private boolean encrypted;
   private boolean disconnected;
   private int packetsReceivedCounter;
   private int packetsSentCounter;
   private float averagePacketsReceived;
   private float averagePacketsSent;
   private int ticks;
   private boolean errored;
   @Nullable
   private volatile DisconnectionInfo pendingDisconnectionInfo;
   @Nullable
   PacketSizeLogger packetSizeLogger;

   public ClientConnection(NetworkSide side) {
      this.side = side;
   }

   public void channelActive(ChannelHandlerContext context) throws Exception {
      super.channelActive(context);
      this.channel = context.channel();
      this.address = this.channel.remoteAddress();
      if (this.pendingDisconnectionInfo != null) {
         this.disconnect(this.pendingDisconnectionInfo);
      }

   }

   public void channelInactive(ChannelHandlerContext context) {
      this.disconnect((Text)Text.translatable("disconnect.endOfStream"));
   }

   public void exceptionCaught(ChannelHandlerContext context, Throwable ex) {
      if (ex instanceof PacketException) {
         LOGGER.debug("Skipping packet due to errors", ex.getCause());
      } else {
         boolean bl = !this.errored;
         this.errored = true;
         if (this.channel.isOpen()) {
            if (ex instanceof TimeoutException) {
               LOGGER.debug("Timeout", ex);
               this.disconnect((Text)Text.translatable("disconnect.timeout"));
            } else {
               Text text = Text.translatable("disconnect.genericReason", "Internal Exception: " + String.valueOf(ex));
               PacketListener packetListener = this.packetListener;
               DisconnectionInfo disconnectionInfo;
               if (packetListener != null) {
                  disconnectionInfo = packetListener.createDisconnectionInfo(text, ex);
               } else {
                  disconnectionInfo = new DisconnectionInfo(text);
               }

               if (bl) {
                  LOGGER.debug("Failed to sent packet", ex);
                  if (this.getOppositeSide() == NetworkSide.CLIENTBOUND) {
                     Packet packet = this.duringLogin ? new LoginDisconnectS2CPacket(text) : new DisconnectS2CPacket(text);
                     this.send((Packet)packet, PacketCallbacks.always(() -> {
                        this.disconnect(disconnectionInfo);
                     }));
                  } else {
                     this.disconnect(disconnectionInfo);
                  }

                  this.tryDisableAutoRead();
               } else {
                  LOGGER.debug("Double fault", ex);
                  this.disconnect(disconnectionInfo);
               }
            }

         }
      }
   }

   protected void channelRead0(ChannelHandlerContext channelHandlerContext, Packet packet) {
      if (this.channel.isOpen()) {
         PacketListener packetListener = this.packetListener;
         if (packetListener == null) {
            throw new IllegalStateException("Received a packet before the packet listener was initialized");
         } else {
            if (packetListener.accepts(packet)) {
               try {
                  handlePacket(packet, packetListener);
               } catch (OffThreadException var5) {
               } catch (RejectedExecutionException var6) {
                  this.disconnect((Text)Text.translatable("multiplayer.disconnect.server_shutdown"));
               } catch (ClassCastException var7) {
                  LOGGER.error("Received {} that couldn't be processed", packet.getClass(), var7);
                  this.disconnect((Text)Text.translatable("multiplayer.disconnect.invalid_packet"));
               }

               ++this.packetsReceivedCounter;
            }

         }
      }
   }

   private static void handlePacket(Packet packet, PacketListener listener) {
      packet.apply(listener);
   }

   private void setPacketListener(NetworkState state, PacketListener listener) {
      Validate.notNull(listener, "packetListener", new Object[0]);
      NetworkSide networkSide = listener.getSide();
      String var10002;
      if (networkSide != this.side) {
         var10002 = String.valueOf(this.side);
         throw new IllegalStateException("Trying to set listener for wrong side: connection is " + var10002 + ", but listener is " + String.valueOf(networkSide));
      } else {
         NetworkPhase networkPhase = listener.getPhase();
         if (state.id() != networkPhase) {
            var10002 = String.valueOf(networkPhase);
            throw new IllegalStateException("Listener protocol (" + var10002 + ") does not match requested one " + String.valueOf(state));
         }
      }
   }

   private static void syncUninterruptibly(ChannelFuture future) {
      try {
         future.syncUninterruptibly();
      } catch (Exception var2) {
         if (var2 instanceof ClosedChannelException) {
            LOGGER.info("Connection closed during protocol change");
         } else {
            throw var2;
         }
      }
   }

   public void transitionInbound(NetworkState state, PacketListener packetListener) {
      this.setPacketListener(state, packetListener);
      if (state.side() != this.getSide()) {
         throw new IllegalStateException("Invalid inbound protocol: " + String.valueOf(state.id()));
      } else {
         this.packetListener = packetListener;
         this.prePlayStateListener = null;
         NetworkStateTransitions.DecoderTransitioner decoderTransitioner = NetworkStateTransitions.decoderTransitioner(state);
         PacketBundleHandler packetBundleHandler = state.bundleHandler();
         if (packetBundleHandler != null) {
            PacketBundler packetBundler = new PacketBundler(packetBundleHandler);
            decoderTransitioner = decoderTransitioner.andThen((context) -> {
               context.pipeline().addAfter("decoder", "bundler", packetBundler);
            });
         }

         syncUninterruptibly(this.channel.writeAndFlush(decoderTransitioner));
      }
   }

   public void transitionOutbound(NetworkState newState) {
      if (newState.side() != this.getOppositeSide()) {
         throw new IllegalStateException("Invalid outbound protocol: " + String.valueOf(newState.id()));
      } else {
         NetworkStateTransitions.EncoderTransitioner encoderTransitioner = NetworkStateTransitions.encoderTransitioner(newState);
         PacketBundleHandler packetBundleHandler = newState.bundleHandler();
         if (packetBundleHandler != null) {
            PacketUnbundler packetUnbundler = new PacketUnbundler(packetBundleHandler);
            encoderTransitioner = encoderTransitioner.andThen((context) -> {
               context.pipeline().addAfter("encoder", "unbundler", packetUnbundler);
            });
         }

         boolean bl = newState.id() == NetworkPhase.LOGIN;
         syncUninterruptibly(this.channel.writeAndFlush(encoderTransitioner.andThen((context) -> {
            this.duringLogin = bl;
         })));
      }
   }

   public void setInitialPacketListener(PacketListener packetListener) {
      if (this.packetListener != null) {
         throw new IllegalStateException("Listener already set");
      } else if (this.side == NetworkSide.SERVERBOUND && packetListener.getSide() == NetworkSide.SERVERBOUND && packetListener.getPhase() == C2S_HANDSHAKE_STATE.id()) {
         this.packetListener = packetListener;
      } else {
         throw new IllegalStateException("Invalid initial listener");
      }
   }

   public void connect(String address, int port, ClientQueryPacketListener listener) {
      this.connect(address, port, QueryStates.C2S, QueryStates.S2C, listener, ConnectionIntent.STATUS);
   }

   public void connect(String address, int port, ClientLoginPacketListener listener) {
      this.connect(address, port, LoginStates.C2S, LoginStates.S2C, listener, ConnectionIntent.LOGIN);
   }

   public void connect(String address, int port, NetworkState outboundState, NetworkState inboundState, ClientPacketListener prePlayStateListener, boolean transfer) {
      this.connect(address, port, outboundState, inboundState, prePlayStateListener, transfer ? ConnectionIntent.TRANSFER : ConnectionIntent.LOGIN);
   }

   private void connect(String address, int port, NetworkState outboundState, NetworkState inboundState, ClientPacketListener prePlayStateListener, ConnectionIntent intent) {
      if (outboundState.id() != inboundState.id()) {
         throw new IllegalStateException("Mismatched initial protocols");
      } else {
         this.prePlayStateListener = prePlayStateListener;
         this.submit((connection) -> {
            this.transitionInbound(inboundState, prePlayStateListener);
            connection.sendImmediately(new HandshakeC2SPacket(SharedConstants.getGameVersion().protocolVersion(), address, port, intent), (ChannelFutureListener)null, true);
            this.transitionOutbound(outboundState);
         });
      }
   }

   public void send(Packet packet) {
      this.send(packet, (ChannelFutureListener)null);
   }

   public void send(Packet packet, @Nullable ChannelFutureListener channelFutureListener) {
      this.send(packet, channelFutureListener, true);
   }

   public void send(Packet packet, @Nullable ChannelFutureListener channelFutureListener, boolean flush) {
      if (this.isOpen()) {
         this.handleQueuedTasks();
         this.sendImmediately(packet, channelFutureListener, flush);
      } else {
         this.queuedTasks.add((connection) -> {
            connection.sendImmediately(packet, channelFutureListener, flush);
         });
      }

   }

   public void submit(Consumer task) {
      if (this.isOpen()) {
         this.handleQueuedTasks();
         task.accept(this);
      } else {
         this.queuedTasks.add(task);
      }

   }

   private void sendImmediately(Packet packet, @Nullable ChannelFutureListener channelFutureListener, boolean flush) {
      ++this.packetsSentCounter;
      if (this.channel.eventLoop().inEventLoop()) {
         this.sendInternal(packet, channelFutureListener, flush);
      } else {
         this.channel.eventLoop().execute(() -> {
            this.sendInternal(packet, channelFutureListener, flush);
         });
      }

   }

   private void sendInternal(Packet packet, @Nullable ChannelFutureListener channelFutureListener, boolean flush) {
      if (channelFutureListener != null) {
         ChannelFuture channelFuture = flush ? this.channel.writeAndFlush(packet) : this.channel.write(packet);
         channelFuture.addListener(channelFutureListener);
      } else if (flush) {
         this.channel.writeAndFlush(packet, this.channel.voidPromise());
      } else {
         this.channel.write(packet, this.channel.voidPromise());
      }

   }

   public void flush() {
      if (this.isOpen()) {
         this.flushInternal();
      } else {
         this.queuedTasks.add(ClientConnection::flushInternal);
      }

   }

   private void flushInternal() {
      if (this.channel.eventLoop().inEventLoop()) {
         this.channel.flush();
      } else {
         this.channel.eventLoop().execute(() -> {
            this.channel.flush();
         });
      }

   }

   private void handleQueuedTasks() {
      if (this.channel != null && this.channel.isOpen()) {
         synchronized(this.queuedTasks) {
            Consumer consumer;
            while((consumer = (Consumer)this.queuedTasks.poll()) != null) {
               consumer.accept(this);
            }

         }
      }
   }

   public void tick() {
      this.handleQueuedTasks();
      PacketListener var2 = this.packetListener;
      if (var2 instanceof TickablePacketListener tickablePacketListener) {
         tickablePacketListener.tick();
      }

      if (!this.isOpen() && !this.disconnected) {
         this.handleDisconnection();
      }

      if (this.channel != null) {
         this.channel.flush();
      }

      if (this.ticks++ % 20 == 0) {
         this.updateStats();
      }

      if (this.packetSizeLogger != null) {
         this.packetSizeLogger.push();
      }

   }

   protected void updateStats() {
      this.averagePacketsSent = MathHelper.lerp(0.75F, (float)this.packetsSentCounter, this.averagePacketsSent);
      this.averagePacketsReceived = MathHelper.lerp(0.75F, (float)this.packetsReceivedCounter, this.averagePacketsReceived);
      this.packetsSentCounter = 0;
      this.packetsReceivedCounter = 0;
   }

   public SocketAddress getAddress() {
      return this.address;
   }

   public String getAddressAsString(boolean logIps) {
      if (this.address == null) {
         return "local";
      } else {
         return logIps ? this.address.toString() : "IP hidden";
      }
   }

   public void disconnect(Text disconnectReason) {
      this.disconnect(new DisconnectionInfo(disconnectReason));
   }

   public void disconnect(DisconnectionInfo disconnectionInfo) {
      if (this.channel == null) {
         this.pendingDisconnectionInfo = disconnectionInfo;
      }

      if (this.isOpen()) {
         this.channel.close().awaitUninterruptibly();
         this.disconnectionInfo = disconnectionInfo;
      }

   }

   public boolean isLocal() {
      return this.channel instanceof LocalChannel || this.channel instanceof LocalServerChannel;
   }

   public NetworkSide getSide() {
      return this.side;
   }

   public NetworkSide getOppositeSide() {
      return this.side.getOpposite();
   }

   public static ClientConnection connect(InetSocketAddress address, boolean useEpoll, @Nullable MultiValueDebugSampleLogImpl packetSizeLog) {
      ClientConnection clientConnection = new ClientConnection(NetworkSide.CLIENTBOUND);
      if (packetSizeLog != null) {
         clientConnection.resetPacketSizeLog(packetSizeLog);
      }

      ChannelFuture channelFuture = connect(address, useEpoll, clientConnection);
      channelFuture.syncUninterruptibly();
      return clientConnection;
   }

   public static ChannelFuture connect(InetSocketAddress address, boolean useEpoll, final ClientConnection connection) {
      Class class_;
      EventLoopGroup eventLoopGroup;
      if (Epoll.isAvailable() && useEpoll) {
         class_ = EpollSocketChannel.class;
         eventLoopGroup = (EventLoopGroup)EPOLL_CLIENT_IO_GROUP.get();
      } else {
         class_ = NioSocketChannel.class;
         eventLoopGroup = (EventLoopGroup)CLIENT_IO_GROUP.get();
      }

      return ((Bootstrap)((Bootstrap)((Bootstrap)(new Bootstrap()).group(eventLoopGroup)).handler(new ChannelInitializer() {
         protected void initChannel(Channel channel) {
            try {
               channel.config().setOption(ChannelOption.TCP_NODELAY, true);
            } catch (ChannelException var3) {
            }

            ChannelPipeline channelPipeline = channel.pipeline().addLast("timeout", new ReadTimeoutHandler(30));
            ClientConnection.addHandlers(channelPipeline, NetworkSide.CLIENTBOUND, false, connection.packetSizeLogger);
            connection.addFlowControlHandler(channelPipeline);
         }
      })).channel(class_)).connect(address.getAddress(), address.getPort());
   }

   private static String getOutboundHandlerName(boolean sendingSide) {
      return sendingSide ? "encoder" : "outbound_config";
   }

   private static String getInboundHandlerName(boolean receivingSide) {
      return receivingSide ? "decoder" : "inbound_config";
   }

   public void addFlowControlHandler(ChannelPipeline pipeline) {
      pipeline.addLast("hackfix", new ChannelOutboundHandlerAdapter(this) {
         public void write(ChannelHandlerContext context, Object value, ChannelPromise promise) throws Exception {
            super.write(context, value, promise);
         }
      }).addLast("packet_handler", this);
   }

   public static void addHandlers(ChannelPipeline pipeline, NetworkSide side, boolean local, @Nullable PacketSizeLogger packetSizeLogger) {
      NetworkSide networkSide = side.getOpposite();
      boolean bl = side == NetworkSide.SERVERBOUND;
      boolean bl2 = networkSide == NetworkSide.SERVERBOUND;
      pipeline.addLast("splitter", getSplitter(packetSizeLogger, local)).addLast(new ChannelHandler[]{new FlowControlHandler()}).addLast(getInboundHandlerName(bl), (ChannelHandler)(bl ? new DecoderHandler(C2S_HANDSHAKE_STATE) : new NetworkStateTransitions.InboundConfigurer())).addLast("prepender", getPrepender(local)).addLast(getOutboundHandlerName(bl2), (ChannelHandler)(bl2 ? new EncoderHandler(C2S_HANDSHAKE_STATE) : new NetworkStateTransitions.OutboundConfigurer()));
   }

   private static ChannelOutboundHandler getPrepender(boolean local) {
      return (ChannelOutboundHandler)(local ? new LocalBufPacker() : new SizePrepender());
   }

   private static ChannelInboundHandler getSplitter(@Nullable PacketSizeLogger packetSizeLogger, boolean local) {
      if (!local) {
         return new SplitterHandler(packetSizeLogger);
      } else {
         return (ChannelInboundHandler)(packetSizeLogger != null ? new PacketSizeLogHandler(packetSizeLogger) : new LocalBufUnpacker());
      }
   }

   public static void addLocalValidator(ChannelPipeline pipeline, NetworkSide side) {
      addHandlers(pipeline, side, true, (PacketSizeLogger)null);
   }

   public static ClientConnection connectLocal(SocketAddress address) {
      final ClientConnection clientConnection = new ClientConnection(NetworkSide.CLIENTBOUND);
      ((Bootstrap)((Bootstrap)((Bootstrap)(new Bootstrap()).group((EventLoopGroup)LOCAL_CLIENT_IO_GROUP.get())).handler(new ChannelInitializer() {
         protected void initChannel(Channel channel) {
            ChannelPipeline channelPipeline = channel.pipeline();
            ClientConnection.addLocalValidator(channelPipeline, NetworkSide.CLIENTBOUND);
            clientConnection.addFlowControlHandler(channelPipeline);
         }
      })).channel(LocalChannel.class)).connect(address).syncUninterruptibly();
      return clientConnection;
   }

   public void setupEncryption(Cipher decryptionCipher, Cipher encryptionCipher) {
      this.encrypted = true;
      this.channel.pipeline().addBefore("splitter", "decrypt", new PacketDecryptor(decryptionCipher));
      this.channel.pipeline().addBefore("prepender", "encrypt", new PacketEncryptor(encryptionCipher));
   }

   public boolean isEncrypted() {
      return this.encrypted;
   }

   public boolean isOpen() {
      return this.channel != null && this.channel.isOpen();
   }

   public boolean isChannelAbsent() {
      return this.channel == null;
   }

   @Nullable
   public PacketListener getPacketListener() {
      return this.packetListener;
   }

   @Nullable
   public DisconnectionInfo getDisconnectionInfo() {
      return this.disconnectionInfo;
   }

   public void tryDisableAutoRead() {
      if (this.channel != null) {
         this.channel.config().setAutoRead(false);
      }

   }

   public void setCompressionThreshold(int compressionThreshold, boolean rejectsBadPackets) {
      if (compressionThreshold >= 0) {
         ChannelHandler var4 = this.channel.pipeline().get("decompress");
         if (var4 instanceof PacketInflater) {
            PacketInflater packetInflater = (PacketInflater)var4;
            packetInflater.setCompressionThreshold(compressionThreshold, rejectsBadPackets);
         } else {
            this.channel.pipeline().addAfter("splitter", "decompress", new PacketInflater(compressionThreshold, rejectsBadPackets));
         }

         var4 = this.channel.pipeline().get("compress");
         if (var4 instanceof PacketDeflater) {
            PacketDeflater packetDeflater = (PacketDeflater)var4;
            packetDeflater.setCompressionThreshold(compressionThreshold);
         } else {
            this.channel.pipeline().addAfter("prepender", "compress", new PacketDeflater(compressionThreshold));
         }
      } else {
         if (this.channel.pipeline().get("decompress") instanceof PacketInflater) {
            this.channel.pipeline().remove("decompress");
         }

         if (this.channel.pipeline().get("compress") instanceof PacketDeflater) {
            this.channel.pipeline().remove("compress");
         }
      }

   }

   public void handleDisconnection() {
      if (this.channel != null && !this.channel.isOpen()) {
         if (this.disconnected) {
            LOGGER.warn("handleDisconnection() called twice");
         } else {
            this.disconnected = true;
            PacketListener packetListener = this.getPacketListener();
            PacketListener packetListener2 = packetListener != null ? packetListener : this.prePlayStateListener;
            if (packetListener2 != null) {
               DisconnectionInfo disconnectionInfo = (DisconnectionInfo)Objects.requireNonNullElseGet(this.getDisconnectionInfo(), () -> {
                  return new DisconnectionInfo(Text.translatable("multiplayer.disconnect.generic"));
               });
               packetListener2.onDisconnected(disconnectionInfo);
            }

         }
      }
   }

   public float getAveragePacketsReceived() {
      return this.averagePacketsReceived;
   }

   public float getAveragePacketsSent() {
      return this.averagePacketsSent;
   }

   public void resetPacketSizeLog(MultiValueDebugSampleLogImpl log) {
      this.packetSizeLogger = new PacketSizeLogger(log);
   }

   // $FF: synthetic method
   protected void channelRead0(final ChannelHandlerContext context, final Object packet) throws Exception {
      this.channelRead0(context, (Packet)packet);
   }

   static {
      C2S_HANDSHAKE_STATE = HandshakeStates.C2S;
   }
}
