package net.minecraft.world.gen.treedecorator;

import com.mojang.serialization.Codec;
import com.mojang.serialization.MapCodec;
import com.mojang.serialization.codecs.RecordCodecBuilder;
import java.util.List;
import net.minecraft.block.BlockState;
import net.minecraft.block.Blocks;
import net.minecraft.block.HangingMossBlock;
import net.minecraft.registry.RegistryKeys;
import net.minecraft.util.Util;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.random.Random;
import net.minecraft.world.StructureWorldAccess;
import net.minecraft.world.gen.feature.ConfiguredFeature;
import net.minecraft.world.gen.feature.VegetationConfiguredFeatures;
import org.apache.commons.lang3.mutable.Mutable;
import org.apache.commons.lang3.mutable.MutableObject;

public class PaleMossTreeDecorator extends TreeDecorator {
   public static final MapCodec CODEC = RecordCodecBuilder.mapCodec((instance) -> {
      return instance.group(Codec.floatRange(0.0F, 1.0F).fieldOf("leaves_probability").forGetter((treeDecorator) -> {
         return treeDecorator.leavesProbability;
      }), Codec.floatRange(0.0F, 1.0F).fieldOf("trunk_probability").forGetter((treeDecorator) -> {
         return treeDecorator.trunkProbability;
      }), Codec.floatRange(0.0F, 1.0F).fieldOf("ground_probability").forGetter((treeDecorator) -> {
         return treeDecorator.groundProbability;
      })).apply(instance, PaleMossTreeDecorator::new);
   });
   private final float leavesProbability;
   private final float trunkProbability;
   private final float groundProbability;

   protected TreeDecoratorType getType() {
      return TreeDecoratorType.PALE_MOSS;
   }

   public PaleMossTreeDecorator(float leavesProbability, float trunkProbability, float groundProbability) {
      this.leavesProbability = leavesProbability;
      this.trunkProbability = trunkProbability;
      this.groundProbability = groundProbability;
   }

   public void generate(TreeDecorator.Generator generator) {
      Random random = generator.getRandom();
      StructureWorldAccess structureWorldAccess = (StructureWorldAccess)generator.getWorld();
      List list = Util.copyShuffled(generator.getLogPositions(), random);
      if (!list.isEmpty()) {
         Mutable mutable = new MutableObject((BlockPos)list.getFirst());
         list.forEach((pos) -> {
            if (pos.getY() < ((BlockPos)mutable.getValue()).getY()) {
               mutable.setValue(pos);
            }

         });
         BlockPos blockPos = (BlockPos)mutable.getValue();
         if (random.nextFloat() < this.groundProbability) {
            structureWorldAccess.getRegistryManager().getOptional(RegistryKeys.CONFIGURED_FEATURE).flatMap((registry) -> {
               return registry.getOptional(VegetationConfiguredFeatures.PALE_MOSS_PATCH);
            }).ifPresent((entry) -> {
               ((ConfiguredFeature)entry.value()).generate(structureWorldAccess, structureWorldAccess.toServerWorld().getChunkManager().getChunkGenerator(), random, blockPos.up());
            });
         }

         generator.getLogPositions().forEach((pos) -> {
            if (random.nextFloat() < this.trunkProbability) {
               BlockPos blockPos = pos.down();
               if (generator.isAir(blockPos)) {
                  decorate(blockPos, generator);
               }
            }

         });
         generator.getLeavesPositions().forEach((pos) -> {
            if (random.nextFloat() < this.leavesProbability) {
               BlockPos blockPos = pos.down();
               if (generator.isAir(blockPos)) {
                  decorate(blockPos, generator);
               }
            }

         });
      }
   }

   private static void decorate(BlockPos pos, TreeDecorator.Generator generator) {
      while(generator.isAir(pos.down()) && !((double)generator.getRandom().nextFloat() < 0.5)) {
         generator.replace(pos, (BlockState)Blocks.PALE_HANGING_MOSS.getDefaultState().with(HangingMossBlock.TIP, false));
         pos = pos.down();
      }

      generator.replace(pos, (BlockState)Blocks.PALE_HANGING_MOSS.getDefaultState().with(HangingMossBlock.TIP, true));
   }
}
