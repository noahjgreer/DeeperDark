package net.minecraft.world.chunk;

import com.mojang.logging.LogUtils;
import java.util.EnumSet;
import java.util.Objects;
import java.util.concurrent.CompletableFuture;
import net.minecraft.entity.EntityType;
import net.minecraft.entity.SpawnReason;
import net.minecraft.server.world.ServerLightingProvider;
import net.minecraft.server.world.ServerWorld;
import net.minecraft.storage.NbtReadView;
import net.minecraft.storage.ReadView;
import net.minecraft.util.ErrorReporter;
import net.minecraft.util.collection.BoundedRegionArray;
import net.minecraft.util.math.ChunkPos;
import net.minecraft.world.ChunkRegion;
import net.minecraft.world.Heightmap;
import net.minecraft.world.gen.chunk.Blender;
import org.slf4j.Logger;

public class ChunkGenerating {
   private static final Logger LOGGER = LogUtils.getLogger();

   private static boolean isLightOn(Chunk chunk) {
      return chunk.getStatus().isAtLeast(ChunkStatus.LIGHT) && chunk.isLightOn();
   }

   static CompletableFuture noop(ChunkGenerationContext context, ChunkGenerationStep step, BoundedRegionArray chunks, Chunk chunk) {
      return CompletableFuture.completedFuture(chunk);
   }

   static CompletableFuture generateStructures(ChunkGenerationContext context, ChunkGenerationStep step, BoundedRegionArray chunks, Chunk chunk) {
      ServerWorld serverWorld = context.world();
      if (serverWorld.getServer().getSaveProperties().getGeneratorOptions().shouldGenerateStructures()) {
         context.generator().setStructureStarts(serverWorld.getRegistryManager(), serverWorld.getChunkManager().getStructurePlacementCalculator(), serverWorld.getStructureAccessor(), chunk, context.structureManager(), serverWorld.getRegistryKey());
      }

      serverWorld.cacheStructures(chunk);
      return CompletableFuture.completedFuture(chunk);
   }

   static CompletableFuture loadStructures(ChunkGenerationContext context, ChunkGenerationStep step, BoundedRegionArray chunks, Chunk chunk) {
      context.world().cacheStructures(chunk);
      return CompletableFuture.completedFuture(chunk);
   }

   static CompletableFuture generateStructureReferences(ChunkGenerationContext context, ChunkGenerationStep step, BoundedRegionArray chunks, Chunk chunk) {
      ServerWorld serverWorld = context.world();
      ChunkRegion chunkRegion = new ChunkRegion(serverWorld, chunks, step, chunk);
      context.generator().addStructureReferences(chunkRegion, serverWorld.getStructureAccessor().forRegion(chunkRegion), chunk);
      return CompletableFuture.completedFuture(chunk);
   }

   static CompletableFuture populateBiomes(ChunkGenerationContext context, ChunkGenerationStep step, BoundedRegionArray chunks, Chunk chunk) {
      ServerWorld serverWorld = context.world();
      ChunkRegion chunkRegion = new ChunkRegion(serverWorld, chunks, step, chunk);
      return context.generator().populateBiomes(serverWorld.getChunkManager().getNoiseConfig(), Blender.getBlender(chunkRegion), serverWorld.getStructureAccessor().forRegion(chunkRegion), chunk);
   }

   static CompletableFuture populateNoise(ChunkGenerationContext context, ChunkGenerationStep step, BoundedRegionArray chunks, Chunk chunk) {
      ServerWorld serverWorld = context.world();
      ChunkRegion chunkRegion = new ChunkRegion(serverWorld, chunks, step, chunk);
      return context.generator().populateNoise(Blender.getBlender(chunkRegion), serverWorld.getChunkManager().getNoiseConfig(), serverWorld.getStructureAccessor().forRegion(chunkRegion), chunk).thenApply((populated) -> {
         if (populated instanceof ProtoChunk protoChunk) {
            BelowZeroRetrogen belowZeroRetrogen = protoChunk.getBelowZeroRetrogen();
            if (belowZeroRetrogen != null) {
               BelowZeroRetrogen.replaceOldBedrock(protoChunk);
               if (belowZeroRetrogen.hasMissingBedrock()) {
                  belowZeroRetrogen.fillColumnsWithAirIfMissingBedrock(protoChunk);
               }
            }
         }

         return populated;
      });
   }

   static CompletableFuture buildSurface(ChunkGenerationContext context, ChunkGenerationStep step, BoundedRegionArray chunks, Chunk chunk) {
      ServerWorld serverWorld = context.world();
      ChunkRegion chunkRegion = new ChunkRegion(serverWorld, chunks, step, chunk);
      context.generator().buildSurface(chunkRegion, serverWorld.getStructureAccessor().forRegion(chunkRegion), serverWorld.getChunkManager().getNoiseConfig(), chunk);
      return CompletableFuture.completedFuture(chunk);
   }

   static CompletableFuture carve(ChunkGenerationContext context, ChunkGenerationStep step, BoundedRegionArray chunks, Chunk chunk) {
      ServerWorld serverWorld = context.world();
      ChunkRegion chunkRegion = new ChunkRegion(serverWorld, chunks, step, chunk);
      if (chunk instanceof ProtoChunk protoChunk) {
         Blender.createCarvingMasks(chunkRegion, protoChunk);
      }

      context.generator().carve(chunkRegion, serverWorld.getSeed(), serverWorld.getChunkManager().getNoiseConfig(), serverWorld.getBiomeAccess(), serverWorld.getStructureAccessor().forRegion(chunkRegion), chunk);
      return CompletableFuture.completedFuture(chunk);
   }

   static CompletableFuture generateFeatures(ChunkGenerationContext context, ChunkGenerationStep step, BoundedRegionArray chunks, Chunk chunk) {
      ServerWorld serverWorld = context.world();
      Heightmap.populateHeightmaps(chunk, EnumSet.of(Heightmap.Type.MOTION_BLOCKING, Heightmap.Type.MOTION_BLOCKING_NO_LEAVES, Heightmap.Type.OCEAN_FLOOR, Heightmap.Type.WORLD_SURFACE));
      ChunkRegion chunkRegion = new ChunkRegion(serverWorld, chunks, step, chunk);
      context.generator().generateFeatures(chunkRegion, chunk, serverWorld.getStructureAccessor().forRegion(chunkRegion));
      Blender.tickLeavesAndFluids(chunkRegion, chunk);
      return CompletableFuture.completedFuture(chunk);
   }

   static CompletableFuture initializeLight(ChunkGenerationContext context, ChunkGenerationStep step, BoundedRegionArray chunks, Chunk chunk) {
      ServerLightingProvider serverLightingProvider = context.lightingProvider();
      chunk.refreshSurfaceY();
      ((ProtoChunk)chunk).setLightingProvider(serverLightingProvider);
      boolean bl = isLightOn(chunk);
      return serverLightingProvider.initializeLight(chunk, bl);
   }

   static CompletableFuture light(ChunkGenerationContext context, ChunkGenerationStep step, BoundedRegionArray chunks, Chunk chunk) {
      boolean bl = isLightOn(chunk);
      return context.lightingProvider().light(chunk, bl);
   }

   static CompletableFuture generateEntities(ChunkGenerationContext context, ChunkGenerationStep step, BoundedRegionArray chunks, Chunk chunk) {
      if (!chunk.hasBelowZeroRetrogen()) {
         context.generator().populateEntities(new ChunkRegion(context.world(), chunks, step, chunk));
      }

      return CompletableFuture.completedFuture(chunk);
   }

   static CompletableFuture convertToFullChunk(ChunkGenerationContext context, ChunkGenerationStep step, BoundedRegionArray chunks, Chunk chunk) {
      ChunkPos chunkPos = chunk.getPos();
      AbstractChunkHolder abstractChunkHolder = (AbstractChunkHolder)chunks.get(chunkPos.x, chunkPos.z);
      return CompletableFuture.supplyAsync(() -> {
         ProtoChunk protoChunk = (ProtoChunk)chunk;
         ServerWorld serverWorld = context.world();
         WorldChunk worldChunk;
         if (protoChunk instanceof WrapperProtoChunk wrapperProtoChunk) {
            worldChunk = wrapperProtoChunk.getWrappedChunk();
         } else {
            worldChunk = new WorldChunk(serverWorld, protoChunk, (worldChunkx) -> {
               ErrorReporter.Logging logging = new ErrorReporter.Logging(chunk.getErrorReporterContext(), LOGGER);

               try {
                  addEntities(serverWorld, NbtReadView.createList(logging, serverWorld.getRegistryManager(), protoChunk.getEntities()));
               } catch (Throwable var8) {
                  try {
                     logging.close();
                  } catch (Throwable var7) {
                     var8.addSuppressed(var7);
                  }

                  throw var8;
               }

               logging.close();
            });
            abstractChunkHolder.replaceWith(new WrapperProtoChunk(worldChunk, false));
         }

         Objects.requireNonNull(abstractChunkHolder);
         worldChunk.setLevelTypeProvider(abstractChunkHolder::getLevelType);
         worldChunk.loadEntities();
         worldChunk.setLoadedToWorld(true);
         worldChunk.updateAllBlockEntities();
         worldChunk.addChunkTickSchedulers(serverWorld);
         worldChunk.setUnsavedListener(context.unsavedListener());
         return worldChunk;
      }, context.mainThreadExecutor());
   }

   private static void addEntities(ServerWorld world, ReadView.ListReadView entities) {
      if (!entities.isEmpty()) {
         world.addEntities(EntityType.streamFromData(entities, world, SpawnReason.LOAD));
      }

   }
}
